# An Illustrative Analysis

http://fivethirtyeight.com has a clever series of articles on the types of movies different actors make in their careers: https://fivethirtyeight.com/tag/hollywood-taxonomy/

I'd like to do a similar analysis. Let's do this in order:

1) Let's do this analysis for Diego Luna 
2) Let's use a clustering algorithm to determine the different types of movies they make
3) Then, let's write an application that performs this analysis for any actor and test it with Gael García Bernal
4) Let's make the application interactive so that a user can change the actor and the number of movie clusters the method learns.

## Gathering data

### Movie ratings

For this analysis we need to get the movies Diego Luna was in, along with their Rotten Tomatoes ratings. For that we scrape this webpage: https://www.rottentomatoes.com/celebrity/diego_luna.

```{r read_dl, cache=TRUE}
library(tidyverse)
library(rvest)
library(stringr)

# URL base for search
base_url <- "https://www.rottentomatoes.com/celebrity/"

# let's see how this works for Diego Luna

# scrape the table from the website
dl_url <- paste0(base_url, "diego_luna")
dl_html <- read_html(dl_url) 
dl_tab <-  dl_html %>%
  html_nodes("#filmographyTbl") %>%
  html_table() %>%
  magrittr::extract2(1) %>%
  as_tibble()

# clean it up
clean_dl_tab <- dl_tab %>% 
  # make sure the movie is rated
  filter(RATING != "No Score Yet") %>% 
  
  # make the rating look numeric
  mutate(RATING = str_replace(RATING, "%", "")) %>%
  
  # remove producer and director credits
  filter(!str_detect(CREDIT, "Prod") &
         !str_detect(CREDIT, "Dir")) %>%
  
  # convert to proper types
  readr::type_convert()
```

This is what we have so far:

```{r, echo=FALSE}
clean_dl_tab %>% head(7) %>% knitr::kable()
```

### Movie budgets and revenue

For the move budgets and revenue data we scrape this
webpage: http://www.the-numbers.com/movie/budgets/all

```{r read_budget, cache=TRUE}
# scrape the webpage
budget_url <- "http://www.the-numbers.com/movie/budgets/all"
budget_html <- read_html(budget_url)
budget_tab <- budget_html %>%
  html_nodes("table") %>%
  html_table(fill=TRUE) %>%
  magrittr::extract2(1) %>%
  select(-1) %>%
  as_tibble()
```

```{r}
# clean up the result
clean_budget_tab <- budget_tab %>%
  # remove all those NA rows
  filter(!is.na(`Release Date`)) %>%

  # make the budget columns look numeric 
  mutate_at(vars(-1), funs(str_replace(., "\\$", ""))) %>%
  mutate_at(vars(-1), funs(str_replace_all(., ",", ""))) %>%
  
  # rename columns
  rename(release_date=`Release Date`,
         movie=Movie,
         production_budget=`Production Budget`,
         domestic_gross=`Domestic Gross`,
         worldwide_gross=`Worldwide Gross`) %>%
  
  # convert columns to proper types
  type_convert(cols(release_date=col_date(format="%m/%d/%Y"))) %>%
  
  # represent budget and gross in millions
  mutate_at(vars(-1,-2), funs(. / 1e6))
```

This is what we have for that table now:

```{r, echo=FALSE}
clean_budget_tab %>% head(10) %>% knitr::kable()
```

## Manipulating the data

Next, we combine the datasets we obtained to get closer to the plot we want to make

```{r}
joined_tab <- clean_dl_tab %>%
  # join the two tables together
  inner_join(clean_budget_tab, by=c(TITLE="movie")) 
```

This is the result of this manipulation

```{r, echo=FALSE}
joined_tab %>% knitr::kable()
```

## Visualizing the data

Finally we have what we need to make our plot

```{r}
joined_tab %>%
  ggplot() +
    theme_bw() +
    aes(x=RATING, y=domestic_gross) +
    geom_point() +
    labs(title="Diego Luna's movies",
         x="Rotten Tomato Rating",
         y="Domestic gross (Millions)")
```

## Modeling data

Now let's take this data and see if a clustering algorithm partitions these movies into three sensible groups.

```{r}
library(class)
library(broom)

kmeans_result <- joined_tab %>%
  select(RATING, domestic_gross) %>%
  kmeans(centers=3) 

clustered_tab <- kmeans_result %>%
  augment(data=joined_tab) %>%
  rename(cluster=.cluster) %>%
  as_tibble()

kmeans_centers <- kmeans_result %>%
  tidy() %>%
  as_tibble()
```

Let's see how the movies are grouped:

```{r, echo=FALSE}
clustered_tab %>%
  select(TITLE, RATING, domestic_gross, cluster) %>%
  arrange(cluster) %>%
  knitr::kable()
```

## Visualizing model result

Let's remake the same plot, but use color to
indicate the cluster

```{r}
final_plot <- clustered_tab %>%
  ggplot() +
    aes(x=RATING, y=domestic_gross, color=cluster) +
    geom_point(size=2.3) +
    theme_bw() +
    labs(title="Diego Luna's movies",
         x="Rotten Tomatoes rating",
         y="Domestic Gross (Millions)")
final_plot
```

Let's annotate the graph with some movie titles. Since each cluster is represented by an average rating and domestic gross, let's find the movie nearest to the average for its cluster.

```{r}
# join the extended movie table with the centers table
annot_tab <- clustered_tab %>%
  select(title=TITLE, rating=RATING, domestic_gross, cluster) %>%
  left_join(select(kmeans_centers, x1, x2, cluster)) %>%
  
  # calculate the distance of each movie to its center
  mutate(center_dist=sqrt((rating-x1)^2+(domestic_gross-x2)^2)) %>%
  
  # find the movie closest to each center
  group_by(cluster) %>%
  arrange(center_dist) %>%
  slice(1)
```

Now let's annotate the plot with these movie titles:

```{r}
final_plot +
  annotate("text", 
           x=annot_tab$x1,
           y=annot_tab$x2,
           label=annot_tab$title)
```

Roughly, movies are clustered into Star Wars and low vs. high rated movies. The latter seem to have some difference in domestic gross. We could use statistical modeling to see if that's the case, but will skip that for now. Do note also, that the clustering algorithm we used seems to be assigning one of the movies incorrectly, which warrants further investigation.

## Abstracting the analysis

While not a tremendous success, we decide we want to carry on with this analysis. We would like to do this for other actors' movies. To do this let's write a function that performs the steps of this analysis that are specific to an actor.

This function must do the following:

1. Scrape movie ratings from Rotten Tomatoes 
2. Clean up the scraped data
3. Join with the budget data we downloaded previously
4. Perform the clustering algorithm
5. Make the final plot

With this in mind, we write functions for each of these steps, and then make one final function that puts all of these together

First, let's write the scraping function. It will take an actor's name and output the scraped data

```{r}
scrape_rt <- function(actor, base_url="https://www.rottentomatoes.com/celebrity/") {
   url <- paste0(base_url, actor)
    html <- read_html(url) 
    
  html %>%
    html_nodes("#filmographyTbl") %>%
    html_table() %>%
    magrittr::extract2(1) %>%
    as_tibble()
}
```

Ok, let's test it with Gael García Bernal:

```{r scrape_ggb, cache=TRUE}
ggb_tab <- scrape_rt("gael_garcia_bernal") 
ggb_tab %>%
  head() %>%
  knitr::kable()
```

Good start, now let's write the function that cleans up
that table

```{r}
cleanup_rt_tab <- function(data) {
 data  %>% 
  # make sure the movie is rated
  filter(RATING != "No Score Yet") %>% 
  
  # make the rating look numeric
  mutate(RATING = str_replace(RATING, "%", "")) %>%
  
  # remove producer and director credits
  filter(!str_detect(CREDIT, "Prod") &
         !str_detect(CREDIT, "Dir")) %>%
  
  # convert to proper types
  readr::type_convert()
}
```

And let's test that again

```{r}
ggb_tab %>% cleanup_rt_tab() %>%
  head() %>%
  knitr::kable()
```

Next, the function that joins ratings and budgets:

```{r}
join_budget <- function(data) {
  data %>%
  # join the two tables together
  inner_join(clean_budget_tab, by=c(TITLE="movie")) 
}
```

And test it:

```{r}
ggb_tab %>%
  cleanup_rt_tab() %>%
  join_budget() %>%
  head() %>%
  knitr::kable()
```

Two more functions to go. Next, we cluster the movies:

```{r}
cluster_movies <- function(data, k=3) {
  data <- data %>%
    select(rating=RATING, title=TITLE, domestic_gross)
  
  kmeans_result <-  data %>%
    select(rating, domestic_gross) %>%
    kmeans(centers=k) 

  clustered_tab <- kmeans_result %>%
    augment(data=data) %>%
    rename(cluster=.cluster) %>%
    as_tibble()

  kmeans_centers <- kmeans_result %>%
    tidy() %>%
    as_tibble()

   clustered_tab %>%
    left_join(select(kmeans_centers, x1, x2, cluster)) %>%
  
    # calculate the distance of each movie to its center
    mutate(center_dist=sqrt((rating-x1)^2+(domestic_gross-x2)^2))
}
```

And test:

```{r}
ggb_tab %>%
  cleanup_rt_tab() %>%
  join_budget() %>%
  cluster_movies() %>%
  knitr::kable()
```

Finally, the function that makes and annotates the plot

```{r}
plot_movies <- function(data, actor) {
  plt <- data %>% ggplot() +
    aes(x=rating, y=domestic_gross, color=cluster) +
    geom_point(size=2.3) +
    theme_bw() +
    labs(title=paste0(actor, "'s movies"),
         x="Rotten Tomatoes rating",
         y="Domestic Gross (Millions)")
  
  annot_dat <- data %>%
    group_by(cluster) %>%
    arrange(center_dist) %>%
    slice(1)
  
  plt <- plt +
     annotate("text", 
           x=annot_dat$x1,
           y=annot_dat$x2,
           label=annot_dat$title)
  plt
}
```

And a final test:

```{r}
ggb_tab %>%
  cleanup_rt_tab() %>%
  join_budget() %>%
  cluster_movies() %>%
  plot_movies("Gael García Bernal")
```

Now, we can make one final function that puts all of this together:

```{r}
analyze_actor <- function(actor, k=3, base_url="https://www.rottentomatoes.com/celebrity/") {
  # first let's make the name work with RT
  rt_name <- actor %>%
    str_to_lower() %>%
    str_replace_all(" ", "_")
  
  message("Scraping Rotten Tomatoes with name ", rt_name)
  dirty_dat <- scrape_rt(rt_name, base_url=base_url) 
  
  message("Preparing data for analysis")
  clean_dat <- dirty_dat %>%
    cleanup_rt_tab() %>%
    join_budget() 
    
  message("Performing clustering and plotting")
    clean_dat %>% cluster_movies(k=k) %>%
    plot_movies(actor)
}
```

And a final test:

```{r test_bbg, cache=TRUE}
analyze_actor("Gael Garcia Bernal")
```

## Making analyses accessible